# ~/beautybot/app/utils/db.py
"""
Асинхронный модуль работы с SQLite.
Поддерживает:
- masters (мастера) с рабочими часами и рабочими днями
- blocked_dates (выходные/блоки)
- services
- clients (бонусы)
- bookings с проверкой пересечений и подсчётом конца записи
- функции получения доступных слотов на диапазон дней
"""

from pathlib import Path
from typing import List, Dict, Optional, Tuple
from datetime import datetime, date, time, timedelta
import os
import aiosqlite

BASE_DIR = Path(__file__).resolve().parents[1]
DB_PATH = BASE_DIR / "database.db"

# Helper: конвертации времени
def time_to_minutes(t: str) -> int:
    # expecting "HH:MM"
    hh, mm = map(int, t.split(":"))
    return hh * 60 + mm

def minutes_to_time(m: int) -> str:
    hh = m // 60
    mm = m % 60
    return f"{hh:02d}:{mm:02d}"

# -----------------------
# Инициализация БД
# -----------------------
async def init_db() -> None:
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("PRAGMA foreign_keys = ON;")
        # clients
        await db.execute("""
            CREATE TABLE IF NOT EXISTS clients (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                bonus_points INTEGER DEFAULT 0
            );
        """)
        # services
        await db.execute("""
            CREATE TABLE IF NOT EXISTS services (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                price INTEGER DEFAULT 0,
                duration INTEGER DEFAULT 60  -- minutes
            );
        """)
        # masters
        await db.execute("""
            CREATE TABLE IF NOT EXISTS masters (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tg_id INTEGER UNIQUE,
                name TEXT,
                work_start TEXT DEFAULT '09:00',
                work_end TEXT DEFAULT '18:00',
                work_days TEXT DEFAULT '0,1,2,3,4' -- 0=Mon...6=Sun, stored as CSV
            );
        """)
        # blocked dates (full-day offs)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS blocked_dates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                master_id INTEGER,
                date TEXT,
                reason TEXT,
                FOREIGN KEY(master_id) REFERENCES masters(id) ON DELETE CASCADE
            );
        """)
        # bookings
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bookings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                master_id INTEGER,
                service_id INTEGER,
                service_name TEXT,
                date TEXT,        -- YYYY-MM-DD
                time_start TEXT,  -- HH:MM
                time_end TEXT,    -- HH:MM
                status TEXT DEFAULT 'pending', -- pending, confirmed, rejected, cancelled
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(service_id) REFERENCES services(id),
                FOREIGN KEY(master_id) REFERENCES masters(id)
            );
        """)
        await db.commit()

        # seed services если пусто
        async with db.execute("SELECT COUNT(*) FROM services") as cur:
            row = await cur.fetchone()
            count = row[0] if row else 0
        if count == 0:
            await db.executemany(
                "INSERT INTO services (name, price, duration) VALUES (?, ?, ?)",
                [
                    ("Маникюр", 1500, 60),
                    ("Педикюр", 2000, 80),
                    ("Наращивание ресниц", 2500, 90),
                ],
            )
            await db.commit()

        # seed master из .env MASTER_ID если есть и не существует
        master_tg = os.getenv("MASTER_ID")
        if master_tg:
            try:
                mtg = int(master_tg)
                async with db.execute("SELECT id FROM masters WHERE tg_id = ?", (mtg,)) as cur:
                    r = await cur.fetchone()
                if not r:
                    await db.execute("INSERT INTO masters (tg_id, name) VALUES (?, ?)", (mtg, f"Master {mtg}"))
                    await db.commit()
            except Exception:
                pass

# -----------------------
# Masters (управление рабочим графиком)
# -----------------------
async def add_master(tg_id: int, name: Optional[str] = None, work_start: str = "09:00", work_end: str = "18:00", work_days: str = "0,1,2,3,4"):
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT id FROM masters WHERE tg_id = ?", (tg_id,)) as cur:
            row = await cur.fetchone()
        if row:
            await db.execute("UPDATE masters SET name = ?, work_start = ?, work_end = ?, work_days = ? WHERE tg_id = ?", (name, work_start, work_end, work_days, tg_id))
        else:
            await db.execute("INSERT INTO masters (tg_id, name, work_start, work_end, work_days) VALUES (?, ?, ?, ?, ?)", (tg_id, name, work_start, work_end, work_days))
        await db.commit()

async def set_master_schedule(tg_id: int, work_start: str, work_end: str, work_days: str):
    await add_master(tg_id, None, work_start, work_end, work_days)

async def add_blocked_date(tg_id: int, date_str: str, reason: Optional[str] = None):
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT id FROM masters WHERE tg_id = ?", (tg_id,)) as cur:
            m = await cur.fetchone()
        if not m:
            return False
        master_id = m["id"] if isinstance(m, aiosqlite.Row) else m[0]
        await db.execute("INSERT INTO blocked_dates (master_id, date, reason) VALUES (?, ?, ?)", (master_id, date_str, reason))
        await db.commit()
        return True

async def remove_blocked_date(tg_id: int, date_str: str):
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT id FROM masters WHERE tg_id = ?", (tg_id,)) as cur:
            m = await cur.fetchone()
        if not m:
            return False
        master_id = m["id"] if isinstance(m, aiosqlite.Row) else m[0]
        await db.execute("DELETE FROM blocked_dates WHERE master_id = ? AND date = ?", (master_id, date_str))
        await db.commit()
        return True

# -----------------------
# Services / Clients / Bookings (основные)
# -----------------------
async def get_services() -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT id, name, price, duration FROM services ORDER BY id") as cur:
            rows = await cur.fetchall()
        return [dict(r) for r in rows]

async def get_service(service_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM services WHERE id = ?", (service_id,)) as cur:
            r = await cur.fetchone()
        return dict(r) if r else None

# clients
async def add_user(user_id: int, username: Optional[str] = None) -> None:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT user_id FROM clients WHERE user_id = ?", (user_id,)) as cur:
            row = await cur.fetchone()
        if row:
            if username is not None:
                await db.execute("UPDATE clients SET username = ? WHERE user_id = ?", (username, user_id))
        else:
            await db.execute("INSERT INTO clients (user_id, username, bonus_points) VALUES (?, ?, 0)", (user_id, username))
        await db.commit()

async def get_client_points(user_id: int) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT bonus_points FROM clients WHERE user_id = ?", (user_id,)) as cur:
            row = await cur.fetchone()
        return int(row[0]) if row and row[0] is not None else 0

async def add_loyalty_points(user_id: int, points: int) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT bonus_points FROM clients WHERE user_id = ?", (user_id,)) as cur:
            row = await cur.fetchone()
        if row:
            new_points = (row["bonus_points"] or 0) + points
            await db.execute("UPDATE clients SET bonus_points = ? WHERE user_id = ?", (new_points, user_id))
        else:
            new_points = points
            await db.execute("INSERT INTO clients (user_id, username, bonus_points) VALUES (?, ?, ?)", (user_id, None, new_points))
        await db.commit()
        return int(new_points)

# bookings
async def get_booking_by_id(booking_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT b.*, s.price AS service_price FROM bookings b LEFT JOIN services s ON b.service_id = s.id WHERE b.id = ?", (booking_id,)) as cur:
            r = await cur.fetchone()
        return dict(r) if r else None

async def get_pending_bookings() -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT b.*, m.tg_id as master_tg FROM bookings b LEFT JOIN masters m ON b.master_id = m.id WHERE b.status = 'pending' ORDER BY b.created_at") as cur:
            rows = await cur.fetchall()
        return [dict(r) for r in rows]

get_unconfirmed_bookings = get_pending_bookings

async def get_user_bookings(user_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT id, service_name, date, time_start, time_end, status FROM bookings WHERE user_id = ? ORDER BY date DESC, time_start DESC", (user_id,)) as cur:
            rows = await cur.fetchall()
        return [dict(r) for r in rows]

get_bookings_by_user = get_user_bookings

# check overlap for same master on date
def _intervals_overlap(s1: int, e1: int, s2: int, e2: int) -> bool:
    return not (e1 <= s2 or e2 <= s1)

async def _master_internal_id_by_tg(tg_id: int) -> Optional[int]:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT id FROM masters WHERE tg_id = ?", (tg_id,)) as cur:
            r = await cur.fetchone()
        if not r:
            return None
        try:
            return int(r[0])
        except:
            return int(r["id"])

async def create_booking(user_id: int, service_id: int, date_str: Optional[str] = None, time_str: Optional[str] = None, master_tg: Optional[int] = None) -> Optional[int]:
    """
    Создаёт booking и возвращает id.
    Возвращает None если слот занят или ошибка.
    """
    if date_str is None:
        date_str = datetime.now().date().isoformat()
    if time_str is None:
        time_str = datetime.now().strftime("%H:%M")

    svc = await get_service(service_id)
    if not svc:
        return None
    duration = int(svc.get("duration") or 60)
    # compute end time
    start_min = time_to_minutes(time_str)
    end_min = start_min + duration
    time_end = minutes_to_time(end_min)

    # resolve master internal id
    if master_tg is None:
        try:
            master_tg = int(os.getenv("MASTER_ID", "0")) or None
        except:
            master_tg = None

    master_id = None
    if master_tg:
        master_id = await _master_internal_id_by_tg(int(master_tg))
        if master_id is None:
            # master not in DB — create
            await add_master(master_tg, f"Master {master_tg}")
            master_id = await _master_internal_id_by_tg(int(master_tg))

    # check blocked date
    if master_id:
        async with aiosqlite.connect(DB_PATH) as db:
            async with db.execute("SELECT 1 FROM blocked_dates WHERE master_id = ? AND date = ?", (master_id, date_str)) as cur:
                blocked = await cur.fetchone()
            if blocked:
                return None

    # check conflicts for same master (pending or confirmed)
    if master_id:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            async with db.execute("SELECT time_start, time_end FROM bookings WHERE master_id = ? AND date = ? AND status IN ('pending','confirmed')", (master_id, date_str)) as cur:
                rows = await cur.fetchall()
            for r in rows:
                s2 = time_to_minutes(r["time_start"])
                e2 = time_to_minutes(r["time_end"])
                if _intervals_overlap(start_min, end_min, s2, e2):
                    return None

    # insert booking
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO bookings (user_id, master_id, service_id, service_name, date, time_start, time_end, status) VALUES (?, ?, ?, ?, ?, ?, ?, 'pending')",
            (user_id, master_id, service_id, svc["name"], date_str, time_str, time_end)
        )
        await db.commit()
        async with db.execute("SELECT last_insert_rowid()") as cur:
            row = await cur.fetchone()
        return int(row[0]) if row else None

# -----------------------
# Calendar / available slots
# -----------------------
async def get_available_slots(master_tg: Optional[int], service_id: int, from_date: Optional[str] = None, days: int = 60) -> Dict[str, List[str]]:
    """
    Возвращает доступные слоты для мастера (по tg id) и услуги на диапазон дней.
    Результат: { 'YYYY-MM-DD': ['HH:MM', ...], ... }
    """
    if from_date is None:
        start_date = datetime.now().date()
    else:
        start_date = datetime.fromisoformat(from_date).date()

    svc = await get_service(service_id)
    if not svc:
        return {}

    duration = int(svc.get("duration") or 60)
    master_id = None
    if master_tg:
        master_id = await _master_internal_id_by_tg(int(master_tg))
        if master_id is None:
            return {}

    result = {}
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        # fetch master schedule
        if master_id:
            async with db.execute("SELECT work_start, work_end, work_days FROM masters WHERE id = ?", (master_id,)) as cur:
                mrow = await cur.fetchone()
            if not mrow:
                return {}
            work_start = mrow["work_start"]
            work_end = mrow["work_end"]
            work_days = [int(x) for x in (mrow["work_days"] or "").split(",") if x != ""]
        else:
            # default schedule
            work_start, work_end, work_days = "09:00", "18:00", [0,1,2,3,4]

        # gather blocked dates set
        blocked = set()
        if master_id:
            async with db.execute("SELECT date FROM blocked_dates WHERE master_id = ?", (master_id,)) as cur:
                brows = await cur.fetchall()
            blocked = set([r["date"] for r in brows])

        # gather existing bookings for needed dates (to speed up)
        end_date = start_date + timedelta(days=days-1)
        if master_id:
            async with db.execute("SELECT date, time_start, time_end FROM bookings WHERE master_id = ? AND date BETWEEN ? AND ? AND status IN ('pending','confirmed')", (master_id, start_date.isoformat(), end_date.isoformat())) as cur:
                exist_rows = await cur.fetchall()
            bookings_by_date = {}
            for r in exist_rows:
                bookings_by_date.setdefault(r["date"], []).append((r["time_start"], r["time_end"]))
        else:
            bookings_by_date = {}

        # build slots per day
        ws = time_to_minutes(work_start)
        we = time_to_minutes(work_end)

        for d in range(days):
            day = start_date + timedelta(days=d)
            wday = day.weekday()  # Monday=0
            iso = day.isoformat()
            if wday not in work_days:
                continue
            if iso in blocked:
                continue

            slots = []
            t = ws
            while t + duration <= we:
                tstr = minutes_to_time(t)
                # check conflict
                conflict = False
                if master_id:
                    for (s_exist, e_exist) in bookings_by_date.get(iso, []):
                        s2 = time_to_minutes(s_exist)
                        e2 = time_to_minutes(e_exist)
                        if _intervals_overlap(t, t + duration, s2, e2):
                            conflict = True
                            break
                if not conflict:
                    slots.append(tstr)
                t += duration  # step = service duration (simple)
            if slots:
                result[iso] = slots

    return result

# -----------------------
# Update booking status
# -----------------------
async def update_booking_status(booking_id: int, status: str) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE bookings SET status = ? WHERE id = ?", (status, booking_id))
        await db.commit()
        return True
